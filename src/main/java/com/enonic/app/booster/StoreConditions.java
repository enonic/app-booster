package com.enonic.app.booster;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiFunction;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.enonic.app.booster.servlet.CachingResponse;
import com.enonic.app.booster.servlet.RequestAttributes;
import com.enonic.app.booster.servlet.RequestUtils;
import com.enonic.app.booster.utils.Matchers;
import com.enonic.app.booster.utils.MimeTypes;
import com.enonic.xp.branch.Branch;
import com.enonic.xp.content.ContentPath;
import com.enonic.xp.portal.PortalRequest;
import com.enonic.xp.portal.RenderMode;
import com.enonic.xp.site.Site;

public class StoreConditions
{
    private static final Logger LOG = LoggerFactory.getLogger( StoreConditions.class );

    List<BiFunction<HttpServletRequest, CachingResponse, Boolean>> extraStoreConditions;

    @SafeVarargs
    public StoreConditions( BiFunction<HttpServletRequest, CachingResponse, Boolean>... extraStoreConditions )
    {
        this.extraStoreConditions = List.of( extraStoreConditions );
    }

    public boolean check( final HttpServletRequest request, final CachingResponse response )
    {
        // In case of HEAD method there might be an empty body. We definitely don't want to cache it.
        // In fact, we don't want to cache responses for requests with anything except GET method.
        if ( !"GET".equalsIgnoreCase( request.getMethod() ) )
        {
            LOG.debug( "Not caching response for request with method {}", request.getMethod() );
            return false;
        }

        // responses with session are not cached - because session is bound to a specific user
        if ( request.getSession( false ) != null )
        {
            LOG.debug( "Not cacheable because Session is created" );
            return false;
        }

        // responses with detail code other than 200 are not cached. This is for the initial implementation.
        final int responseStatus = response.getStatus();
        if ( responseStatus != 200 )
        {
            LOG.debug( "Not cacheable detail code {}", responseStatus );
            return false;
        }

        // We may cache responses with Vary header, but it is quite a bit of work to parse and check it
        if ( response.getCachedHeaders().containsKey( "vary" ) )
        {
            LOG.debug( "Not cacheable because of Vary header in response" );
            return false;
        }

        // something very sneaky is going on here. Page controller returns compressed data! We better of not caching it for now (because we apply compression ourselves)
        if ( response.getCachedHeaders().containsKey( "content-encoding" ) )
        {
            LOG.debug( "Not cacheable because of pre-set content-encoding in response" );
            return false;
        }

        // Expires header is often used to indicate that response must not be cached
        // It can also be used to indicate that response could be cached, but it is not reliable
        // We better of not caching responses with Expires header
        if ( response.containsHeader( "Expires" ) )
        {
            LOG.debug( "Not cacheable because of expires header in response" );
            return false;
        }

        // Check if there are cache headers in the response that prevent caching
        if ( response.getFreshness().notCacheable() )
        {
            LOG.debug( "Not cacheable because of cache-control headers in response" );
            return false;
        }

        // Check if there are extra storeConditions
        for ( var extraStoreCondition : extraStoreConditions )
        {
            if ( !extraStoreCondition.apply( request, response ) )
            {
                return false;
            }
        }

        return true;
    }

    public static class PortalRequestConditions
    {
        public boolean check( HttpServletRequest request, CachingResponse response )
        {
            final PortalRequest portalRequest = RequestAttributes.getPortalRequest( request );
            if ( portalRequest == null )
            {
                LOG.debug( "Not cacheable because response was not generated by site engine" );
                return false;
            }

            final RenderMode renderMode = portalRequest.getMode();
            if ( RenderMode.LIVE != renderMode )
            {
                LOG.debug( "Not cacheable because site engine render mode is {}", renderMode );
                return false;
            }

            // only cache in LIVE mode, and only master branch
            final Branch requestBranch = portalRequest.getBranch();
            if ( !requestBranch.equals( Branch.from( "master" ) ) )
            {
                LOG.debug( "Not cacheable because of site engine branch is {}", requestBranch );
                return false;
            }
            return true;
        }
    }

    public static class SiteConfigConditions
    {
        private final Set<String> excludeQueryParams;

        public SiteConfigConditions( final Set<String> excludeQueryParams )
        {
            this.excludeQueryParams = excludeQueryParams;
        }

        public boolean check( HttpServletRequest request, CachingResponse response )
        {
            final PortalRequest portalRequest = RequestAttributes.getPortalRequest( request );
            final BoosterSiteConfig config = BoosterSiteConfig.getSiteConfig( portalRequest );

            // site must have booster application
            if ( config == null )
            {
                LOG.debug( "Not cacheable because site booster app is not enabled for this site" );
                return false;
            }

            final Integer fallbackTTL =
                config.componentTTL != null && RequestUtils.isComponentRequest( request ) ? config.componentTTL : config.defaultTTL;
            if ( Integer.valueOf( 0 ).equals( fallbackTTL ) )
            {
                LOG.debug( "Not cacheable because TTL is set to 0" );
                return false;
            }

            if ( !checkPaths( request, config.patterns, portalRequest ) )
            {
                return false;
            }

            if ( !checkBypassHeaders( config.bypassHeaders, request ) )
            {
                return false;
            }

            if ( !checkBypassCookies( config.bypassCookies, request ) )
            {
                return false;
            }

            return true;
        }

        public boolean checkPaths( final HttpServletRequest request, final List<InvertablePattern> patterns,
                                   final PortalRequest portalRequest )
        {
            if ( patterns.isEmpty() )
            {
                return true;
            }
            else
            {
                final String siteRelativePath = siteRelativePath( portalRequest.getSite(), portalRequest.getContentPath() );
                for ( var pattern : patterns )
                {
                    if ( Matchers.matchesUrlPattern( pattern.pattern(), pattern.invert(), siteRelativePath, excludeQueryParams, request.getParameterMap() ) )
                    {
                        return true;
                    }
                }
                LOG.debug( "Not cacheable because of path does not match any pattern" );
                return false;
            }
        }

        private static String siteRelativePath( final Site site, final ContentPath contentPath )
        {
            if ( site == null )
            {
                return contentPath.toString();
            }
            else if ( site.getPath().equals( contentPath ) )
            {
                return "/";
            }
            else
            {
                return contentPath.toString().substring( site.getPath().toString().length() );
            }
        }
    }

    public static class ContentTypeConditions
    {
        private final Set<String> mimeTypes;

        public ContentTypeConditions( final Set<String> mimeTypes )
        {
            this.mimeTypes = mimeTypes;
        }

        public boolean check( HttpServletRequest request, CachingResponse response )
        {
            final String responseContentType = response.getContentType();
            if ( responseContentType == null || !MimeTypes.isContentTypeSupported( mimeTypes, responseContentType ) )
            {
                LOG.debug( "Not cacheable because of incompatible content-type {}", responseContentType );
                return false;
            }
            return true;
        }
    }

    public static boolean checkBypassHeaders( final List<EntryPattern> headers, final HttpServletRequest request )
    {
        for ( var header : headers )
        {
            final List<String> values =
                Collections.list( Objects.requireNonNullElse( request.getHeaders( header.name() ), Collections.emptyEnumeration() ) );

            if ( Matchers.matchesPattern( header.pattern(), header.invert(), values ) )
            {
                LOG.debug( "Not cacheable because of bypass header pattern match {}", header );
                return false;
            }
        }
        return true;
    }

    public static boolean checkBypassCookies( final List<EntryPattern> cookies, final HttpServletRequest request )
    {
        if ( request.getCookies() != null )
        {
            for ( var cookie : cookies )
            {
                final List<String> values = Arrays.stream( request.getCookies() )
                    .filter( c -> c.getName().equals( cookie.name() ) )
                    .map( Cookie::getValue )
                    .toList();

                if ( Matchers.matchesPattern( cookie.pattern(), cookie.invert(), values ) )
                {
                    LOG.debug( "Not cacheable because of bypass cookie pattern match {}", cookie );
                    return false;
                }
            }
        }
        return true;
    }
}

