package com.enonic.app.booster;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.enonic.app.booster.concurrent.Collapser;
import com.enonic.app.booster.servlet.CachingResponseWrapper;
import com.enonic.app.booster.servlet.RequestUtils;
import com.enonic.app.booster.storage.NodeCacheStore;
import com.enonic.xp.annotation.Order;
import com.enonic.xp.portal.PortalRequest;
import com.enonic.xp.project.ProjectName;
import com.enonic.xp.trace.Trace;
import com.enonic.xp.trace.Tracer;
import com.enonic.xp.web.filter.OncePerRequestFilter;

@Component(immediate = true, service = Filter.class, property = {"connector=xp"}, configurationPid = "com.enonic.app.booster")
@Order(-190)
@WebFilter("/site/*")
public class BoosterRequestFilter
    extends OncePerRequestFilter
{
    private static final Logger LOG = LoggerFactory.getLogger( BoosterRequestFilter.class );

    private final NodeCacheStore cacheStore;

    private volatile BoosterConfigParsed config;

    private final Collapser<CacheItem> requestCollapser = new Collapser<>();

    private final BoosterLicenseService licenseService;

    @Activate
    public BoosterRequestFilter( @Reference final NodeCacheStore cacheStore, @Reference final BoosterLicenseService licenseService)
    {
        this.cacheStore = cacheStore;
        this.licenseService = licenseService;
    }

    @Activate
    @Modified
    public void activate( final BoosterConfig config )
    {
        this.config = BoosterConfigParsed.parse( config );
    }

    @Override
    protected void doHandle( final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain )
        throws Exception
    {
        final Preconditions preconditions = new Preconditions();
        if ( !preconditions.check( request ) || !licenseService.isValidLicense() )
        {
            chain.doFilter( request, response );
            return;
        }

        // Full URL is used, so scheme, domain and port are included.
        // Query String is also included with all parameters (there is an option to exclude some of them in config)
        final RequestUtils.RequestUrl requestUrl = RequestUtils.buildRequestURL( request, config.excludeQueryParams() );

        final String fullUrl = requestUrl.fullUrl();
        final String cacheKey = cacheStore.generateCacheKey( fullUrl );
        final Trace trace = Tracer.newTrace( "booster.fromCache" );
        if ( trace != null )
        {
            trace.put( "cacheKey", cacheKey );
            trace.put( "url", fullUrl );
        }

        LOG.debug( "Normalized URL of request {} with key {}", fullUrl, cacheKey );

        final String[] cacheStatus = new String[1];
        final CacheItem stored = Tracer.traceEx( trace, () -> {
            final CacheItem inCache = cacheStore.get( cacheKey );
            if ( inCache == null )
            {
                LOG.debug( "No cached response found {}", cacheKey );
                cacheStatus[0] = "MISS";
                traceStatus( trace, "MISS" );
                return null;
            }
            final CacheItem valid = getCached( inCache );
            if ( valid != null )
            {
                LOG.debug( "Writing directly from cache {}", cacheKey );
                new CachedResponseWriter( request, config ).write( response, valid );
                cacheStatus[0] = "HIT";
                traceStatus( trace, "HIT" );
                return null;
            }

            LOG.debug( "Cached response is stale {}", cacheKey );
            cacheStatus[0] = "STALE";
            traceStatus( trace, "STALE" );
            return inCache;
        } );

        if ( "HIT".equals( cacheStatus[0] ) )
        {
            return;
        }

        // response is very likely cacheable if stored value exists, we can collapse requests (wait for one request to do rendering)
        final Collapser.Latch<CacheItem> latch = stored != null ? requestCollapser.latch( cacheKey ) : null;

        final CacheItem[] newCached = new CacheItem[1];
        try
        {
            if ( latch != null )
            {
                newCached[0] = latch.get();
                if ( newCached[0] != null )
                {
                    LOG.debug( "Cached response generated by another request. Use collapsed request result {}", cacheKey );
                    new CachedResponseWriter( request, config ).write( response, newCached[0] );
                    return;
                }
            }

            LOG.debug( "Processing request with cache key {}", cacheKey );
            if ( !config.disableXBoosterCacheHeader() )
            {
                response.setHeader( "X-Booster-Cache", "MISS" );
            }

            final Postconditions postconditions = new Postconditions( new Postconditions.PortalRequestConditions()::check,
                                                                      new Postconditions.SiteConfigConditions( config )::check,
                                                                      new Postconditions.ContentTypePreconditions( config )::check );

            final CachingResponseWrapper cachingResponse = new CachingResponseWrapper( request, response, postconditions::check, config );
            try (cachingResponse)
            {
                chain.doFilter( request, cachingResponse );
            }

            LOG.debug( "Response received for cache key {}. Can be stored: {}", cacheKey, cachingResponse.isCached() );
            if ( cachingResponse.isCached() || stored != null )
            {
                Tracer.trace( "booster.updateCache", () -> {
                    if ( cachingResponse.isCached() )
                    {
                        final CacheMeta cacheMeta = createCacheMeta( request, requestUrl );

                        newCached[0] = new CacheItem( cachingResponse.getStatus(), cachingResponse.getContentType(),
                                                      cachingResponse.getCachedHeaders(), Instant.now(), null, cachingResponse.getSize(),
                                                      cachingResponse.getEtag(), cachingResponse.getCachedGzipBody(),
                                                      cachingResponse.getCachedBrBody().orElse( null ) );
                        cacheStore.put( cacheKey, newCached[0], cacheMeta );
                    }
                    else
                    {
                        if ( stored != null )
                        {
                            // Evacuate item from cache immediately if it is no longer cacheable
                            // to prevent needless request collapsing
                            cacheStore.remove( cacheKey );
                        }
                    }
                } );
            }
        }
        finally
        {
            if ( latch != null )
            {
                latch.unlock( newCached[0] );
            }
        }
    }

    private CacheItem getCached( final CacheItem stored )
    {
        if ( stored == null )
        {
            return null;
        }
        if ( stored.invalidatedTime() != null ||
            stored.cachedTime().plus( config.cacheTtlSeconds(), ChronoUnit.SECONDS ).isBefore( Instant.now() ) )
        {
            return null;
        }
        else
        {
            return stored;
        }
    }

    private static CacheMeta createCacheMeta( final HttpServletRequest request, RequestUtils.RequestUrl requestUrl )
    {
        final PortalRequest portalRequest = (PortalRequest) request.getAttribute( PortalRequest.class.getName() );

        final String project;
        if ( portalRequest.getRepositoryId() != null )
        {
            final ProjectName projectName = ProjectName.from( portalRequest.getRepositoryId() );
            project = projectName != null ? projectName.toString() : null;
        }
        else
        {
            project = null;
        }

        final String siteId = portalRequest.getSite() != null ? portalRequest.getSite().getId().toString() : null;
        final String contentId;
        final String contentPath;
        if ( portalRequest.getContent() != null )
        {
            contentId = portalRequest.getContent().getId().toString();
            contentPath = portalRequest.getContent().getPath().toString();
        }
        else
        {
            contentId = null;
            contentPath = null;
        }
        return new CacheMeta( requestUrl.fullUrl(), requestUrl.domain(), requestUrl.path(), project, siteId, contentId, contentPath );
    }

    private static void traceStatus(final Trace trace, final String status) {
        if ( trace != null )
        {
            trace.put( "status", status );
        }
    }
}
