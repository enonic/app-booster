package com.enonic.app.booster;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.enonic.app.booster.concurrent.Collapser;
import com.enonic.app.booster.servlet.CachingResponseWrapper;
import com.enonic.app.booster.servlet.RequestUtils;
import com.enonic.app.booster.storage.NodeCacheStore;
import com.enonic.xp.annotation.Order;
import com.enonic.xp.portal.PortalRequest;
import com.enonic.xp.project.ProjectName;
import com.enonic.xp.web.filter.OncePerRequestFilter;

@Component(immediate = true, service = Filter.class, property = {"connector=xp"}, configurationPid = "com.enonic.app.booster")
@Order(-190)
@WebFilter("/site/*")
public class BoosterRequestFilter
    extends OncePerRequestFilter
{
    private static final Logger LOG = LoggerFactory.getLogger( BoosterRequestFilter.class );

    private final NodeCacheStore cacheStore;

    private volatile BoosterConfigParsed config;

    private final Collapser<CacheItem> requestCollapser = new Collapser<>();

    @Activate
    public BoosterRequestFilter( @Reference final NodeCacheStore cacheStore )
    {
        this.cacheStore = cacheStore;
    }

    @Activate
    @Modified
    public void activate( final BoosterConfig config )
    {
        this.config = BoosterConfigParsed.parse( config );
    }

    @Override
    protected void doHandle( final HttpServletRequest request, final HttpServletResponse response, final FilterChain chain )
        throws Exception
    {
        final Preconditions preconditions = new Preconditions();
        if ( !preconditions.check( request ) )
        {
            chain.doFilter( request, response );
            return;
        }

        // Full URL is used, so scheme, domain and port are included.
        // Query String is also included with all parameters (there is an option to exclude some of them in config)
        final RequestUtils.RequestUrl requestUrl = RequestUtils.buildRequestURL( request, config.excludeQueryParams() );

        final String fullUrl = requestUrl.fullUrl();
        final String cacheKey = cacheStore.generateCacheKey( fullUrl );

        LOG.debug( "Normalized URL of request {} with key {}", fullUrl, cacheKey );

        final CacheItem stored = cacheStore.get( cacheKey );
        final CacheItem cached = getCached( stored );
        if ( stored != null && cached == null )
        {
            LOG.debug( "Cached response is stale {}", cacheKey );
        }

        if ( cached != null )
        {
            LOG.debug( "Writing directly from cache {}", cacheKey );
            new CachedResponseWriter( request, config ).write( response, cached );
            return;
        }

        // response is very likely cacheable if stored value exists, we can collapse requests (wait for one request to do rendering)
        final Collapser.Latch<CacheItem> latch = stored != null ? requestCollapser.latch( cacheKey ) : null;

        CacheItem newCached = null;
        try
        {
            if ( latch != null )
            {
                newCached = latch.get();
                if ( newCached != null )
                {
                    LOG.debug( "Cached response generated by another request. Use collapsed request result {}", cacheKey );
                    new CachedResponseWriter( request, config ).write( response, newCached );
                    return;
                }
            }

            LOG.debug( "Processing request with cache key {}", cacheKey );
            if ( !config.disableXBoosterCacheHeader() )
            {
                response.setHeader( "X-Booster-Cache", "MISS" );
            }

            final Postconditions postconditions = new Postconditions( new Postconditions.PortalRequestConditions()::check,
                                                                      new Postconditions.SiteConfigConditions( config )::check,
                                                                      new Postconditions.ContentTypePreconditions( config )::check );

            final CachingResponseWrapper cachingResponse = new CachingResponseWrapper( request, response, postconditions::check, config );
            try (cachingResponse)
            {
                chain.doFilter( request, cachingResponse );
            }

            LOG.debug( "Response received for cache key {}. Can be stored: {}", cacheKey, cachingResponse.isCached() );

            if ( cachingResponse.isCached() )
            {
                final CacheMeta cacheMeta = createCacheMeta( request, requestUrl );

                newCached =
                    new CacheItem( cachingResponse.getStatus(), cachingResponse.getContentType(), cachingResponse.getCachedHeaders(),
                                   Instant.now(), null, cachingResponse.getSize(), cachingResponse.getEtag(),
                                   cachingResponse.getCachedGzipBody(), cachingResponse.getCachedBrBody().orElse( null ) );
                cacheStore.put( cacheKey, newCached, cacheMeta );
            }
            else
            {
                if ( stored != null )
                {
                    // Evacuate item from cache immediately if it is no longer cacheable
                    // to prevent needless request collapsing
                    cacheStore.remove( cacheKey );
                }
            }

        }
        finally
        {
            if ( latch != null )
            {
                latch.unlock( newCached );
            }
        }
    }

    private CacheItem getCached( final CacheItem stored )
    {
        if ( stored == null )
        {
            return null;
        }
        if ( stored.invalidatedTime() != null ||
            stored.cachedTime().plus( config.cacheTtlSeconds(), ChronoUnit.SECONDS ).isBefore( Instant.now() ) )
        {
            return null;
        }
        else
        {
            return stored;
        }
    }

    private static CacheMeta createCacheMeta( final HttpServletRequest request, RequestUtils.RequestUrl requestUrl )
    {
        final PortalRequest portalRequest = (PortalRequest) request.getAttribute( PortalRequest.class.getName() );

        final String project;
        if ( portalRequest.getRepositoryId() != null )
        {
            final ProjectName projectName = ProjectName.from( portalRequest.getRepositoryId() );
            project = projectName != null ? projectName.toString() : null;
        }
        else
        {
            project = null;
        }

        final String siteId = portalRequest.getSite() != null ? portalRequest.getSite().getId().toString() : null;
        final String contentId;
        final String contentPath;
        if ( portalRequest.getContent() != null )
        {
            contentId = portalRequest.getContent().getId().toString();
            contentPath = portalRequest.getContent().getPath().toString();
        }
        else
        {
            contentId = null;
            contentPath = null;
        }
        return new CacheMeta( requestUrl.fullUrl(), requestUrl.domain(), requestUrl.path(), project, siteId, contentId, contentPath );
    }
}
